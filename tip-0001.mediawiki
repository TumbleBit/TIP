= Tumblebit Improvement Proposal (TIP) =

== TIP 1 ==

=== Background ===

While implementing a demo Tumblebit server in “classic tumbler” mode and after carefully reviewing '''Fig 4 of the [https://eprint.iacr.org/2016/575.pdf white paper] describing interactions between Tumbler and Bob''', I came to the conclusion that steps 2-7 could be simplified (steps 9-12 are unchanged).

The objectives are

# stick to the most common cryptographic primitives (avoid Tumblebit-specific data formats)
# reduce the amount of data flowing back and forth between Tumbler and Bob.
# preserve the security and privay-protection proprerties of the original Tumblebit protocol

Objective 1 is meant to facilitate integration of Tumblebit features into multiple wallet implementations: wallet developpers should be able to use their favorite Bitcoin library with minimal additional code.

=== Proposal ===

Initially, before each payment phase, Tumbler generates a fresh ECDSA key pair (PKT, SKT).

Bob generates an ECDSA key pair,(PKB, SKB), for “real” transactions and picks a single random 256-bit blinding factor r for “fake” transactions. Bob keeps r secret for now and publishes PKB.

In Fig. 4 '''step 2''', Bob generates 42 “real” payout addresses (keeps them secret for now) and prepares 42 distinct “real” transactions.

In '''step 3''', Bob prepares 42 “fake” transactions like so:

Fake transaction i pays Tumbler compressed Bitcoin address (corresponding to PKT) 1 BTC in output 0 (no network fee bearing in mind the transaction will never hit the blockchain ) with an OP_RETURN output (output 1) containing the hex string

<code>r || i</code>

Such fake transaction only sends a full refund to Tumbler and is unlikely to confirm without network fees. ''No need for Bob to generate (and later transmit to Tumbler) a set of 84 random pad values. Bob needs only to generate one regular, Bitcoin key pair and one random blinding factor.''

Bob hides the transactions in 84 sighash values (regular Bitcoin sighash computations here) , permutes them ('''Step 4'''), and finally sends them to Tumbler as beta1, …, beta84.

''Minimized data flow: no need for Bob to send to Tumbler any hR, hF''

In '''Step 5''', Tumbler signs each betai with SKT to create an ECDSA-Secp256k1 signature sigmai. Tumbler picks 84 random 256-bit symetric encryption keys epsilon and computes ci = AES256( epsiloni, sigmai ) ''Minimized data flow: we propose a simple AES256 encryption instead of the complex SHA512 hash specified in the original paper: this yields most of the data traffic reduction''

'''Step 6''': Bob sends to Tumbler the 42 “real” indices along with blinding factor r.

''Minimized data flow: Bob sends a single 256-bit blinding factor r in lieu of a salt value and 42 pad values.''

{|
! Original
!align="center"| Size
! TIP 1
!align="center"| Size
|-
| 84 Betas
|align="center"| 2688 Bytes
|

|align="center"| 2688 Bytes
|-
| hR,hF
|align="center"| 64 Bytes
|

|}
